---
categories:
- 翻译
tags:
- 翻译
---

`原文出处：https://blazingedge.io/blog/my-serverless-adventure`

在`React Native`的几篇文章后，我想谈谈我构建无服务应用的经历，通过`Express/Koa`的`laaS/PaaS`构建标准APIs的经历或者是利用`Fass`服务模型的不同。

如果你想构建一个==lambda==函数，你不需要任何特殊的工具。但是如果你想构建一个真实的应用程序，你可以通过使用工具更容易地管理代码、打包和部署。我们选择的工具是无服务器框架。

#### FaaS 服务模型 ####

在了解如何使用无服务器技术前，我们首先需要知道`FaaS`的含义。`FaaS`（功能是服务）是一种云计算服务模型（诸如`lass，Pass，Saas`等等）的方式，它让我们无需担心代码在运行时服务器的基础设施和硬件是否满足条件，一切都在我们的掌控之内。你仅仅是需要支付一笔你函数计算的费用，当需要充值时。它允许我们创建项目，并且无需考虑闲置服务器的成本，如果我们使用其他的服务器模型。

#### AWS Lamba ####

`AWS Lamba` 是亚马逊在2014年发布的一款`FaaS`产品，7月份的一篇文章中提到，如今它占据着FaaS市场的三分之二。亚马逊凭借早期的策略、免费月度免费计划（价值约6-7美元）以及近乎无敌的价格优势，它将会继续占据着`Fass market`的霸主地位。免费月度计划允许100万次的请求（调用）和400，000GB秒级的计算时间。例如，如果你使用128MB内存的==Lamba==函数，那就意味着你将拥有大约33天的计算时间。对于你而言，这值得试一试，甚至你可以免费的跑一个或者两个项目。

一旦你使用完免费的资源，你需要为每GB秒支付0.00001667美元。

使用Node.js的==AWS Lambda==函数例子：

```
module.exports.hello = (event, context, callback) => {
const response = {
statusCode: 200,
body: JSON.stringify({
message: 'Hello world!',
input: event,
}),
}

callback(null, response)
}
```

当一个HTTP请求通过API网关触发时，==事件==对象的体系就会通过事件源建立起来，它会包含基本的请求头、还有像HTTP请求的路径和方法之类的一些API网关。

上下文==对象==包含了==Lambda==的环境值，`context.getRemainingTimeInMillis()`函数是关键的一个函数，它包含了在函数停止执行的超时之前还有多少毫秒等待执行的信息。



==回调==是一个接收错误和成功参数的函数，遵循JS流行的回调设计模式。因此我们采用一种版本比较新的Node（如8.10），我们可以使用同步函数来替代回调的设计模式，它们依赖成功执行返回的语句和在错误情况下抛出异常。



#### 超时 ####

默认情况下`，AWS Lambda`有15分钟的超时限制（每次请求最大的持续时间）。这是超时的最高值，作为开发者，如果某个函数由于某些原因而失败并决定继续运行直到超时，我们可以分配较低的超市值来减少潜在的成本。如果你有一个函数运行的时间超过15分钟（或者接近），你应该考虑将它分解成几个可以分步执行的不同函数。如果你不分割函数，你可以为它寻找一个可以提供更长运行时间的供货商或者选择不同的服务器模型。这是AWS Lambda的一份清单。

更新：最大持续运行时间过去是5分钟，最近调整为15分钟。



#### 保持活动连接 ####

当用函数执行代码时，要确保你是在连接着其他的服务器，如Redis、数据库等。因为某些服务器对于连接数有限制，比如一些数据库允许10个连接（可以增加）你的无服务器应用会由于无法连接到服务而结束。如果你的无服务器应用是连接数据库和渲染HTML页面的单个函数，那并不意味着你仅仅只需要一个数据库的连接。单个Lambda函数只关心一个事件，当它繁忙时（执行代码），它不接受其他的调用，然而创造出一个新的函数可以增加面向数据库的连接数目。因此，当编写代码时，可以试图利用缓存服务如Redis，因为她有更高的连接数并且在查询数据时速度更快，并且当你利用连接处理完处理事务时，尽可能快速地断开连接，没有连接应该保持活跃。

#### 性能 ####

在Linux环境中AWS会管理并执行代码时，你可以通过两种方式提高性能：每个函数分配的内存和函数实际的代码。谈到内存时，你可以分配128MB到3GB的内存给函数。当增加你的函数使用的内存时（如果你过度分配内存给函数，你的函数会被终止），它也会提高你函数的计算能力（CPU）因此你的代码会被更快地执行。如果你发现你的函数比预期的要慢，可以尝试提高分配的内存并且找到速度和费用之间的平衡点。站在函数代码上来讲，也适用于其他任何的软件，如果你编写性能良好的代码也不应该放慢速度，然而已部署代码的大小可以，尤其是如果你使用的环境启动性能可能受到函数包大小的影响。为了避免这种情况，你可以对你的函数分别地打包，更重要的是你可以使用具有优化的插件。幸运的是，Node.js的环境不会受到包大小带来的巨大影响，但优化总是受欢迎的。

#### 缩放 ####

从你函数使用的情况出发，AWS是理想的因为它们可以无限制地缩放（或者在你达到限制之前，检查超时部分的连接）。如果你的函数正在做图像的优化，从队列中接收消息，我能想到的是保持这部分的连接，一个单函数只能接收一个事件。

我们可以举例处理图像的优化，了解它是如何缩放的。



例1：

用户上传一张图片，第一次触你的函数会触发处理优化。AWS会创建一个新函数，从S3中下咋子啊一个.zip的函数包（你的代码）然后演示必要的操作以便于你的函数能够开始执行，这部分叫做冷启动。它是一个术语/周期。用于表明你的函数不活动，并且它必须被提供以便于对触发它的的事件作出响应。它会持续0.5s到5s，取决于基础设施的复合、代码包的大小、环境等等。另外，它没有计算到你的计算时间。一旦它完成了图片的优化就会返回一个成功的回复，函数将会保持warm一些时间，这个取决于你地区在那个时间点的基础设施的负荷，根据别人的的经历，它会持续5到15分钟。如果当它是warm状态时你的函数被再次触发，它会立即开始执行并且这次没有冷启动。

例2：

上一个的例子中函数仍然是warm的，在同一个时间有两个用户同事上传图片。我们会得到两次事件触发，从上个例子中可知其中一个事件会被分配到warm函数，而AWS为了处理第二个事件会创建一个的新函数，并分配给它。当它不是warm时，它会有一个冷启动并且图片不会立刻被优化。

为了缩放我们的函数，当没有处理任何事件时我们应该分析函数的使用情况并且了解在一个时间点一个单函数会被多少次同时调用，这是否会影响我们优化的性能。如果我们的函数是在执行图像优化，我们不必担心冷启动因为它对我们的用户没有影响。然而，如果我们使用一个Lambda函数去为一个网页服务时，在一天的某些时刻会有一个高峰的请求，为了避免冷启动给性能带来的影响，我们应该使少许的几个，几十个或者几百个函数是warm的，每（毫秒）计数一次，提高用户的体验。如何知道你需要多少函数？你应该在你的应用中做一些分析和监控，以便发现这点。Dashbird.io是一个好的点子，因为它提供监控、错误日志，调试和很多其它实用的功能，它有一个免费月度计划因此你可以没有任何负担地试一下。

你可以使用插件来保持函数warm，或者通过制定云监控事件，它允许你创建很多高级的解决方案：调用一个函数，读取前些天的分析，执行计算，并根据当前情况调用X函数而不是盲目地调用Y函数。

我也了解到API网关（HTTP路由针对你的解决方案）可以给你的应用增加一些延迟，因为它就是你依赖（我认为延迟是最小化的）另一个服务，可以实现直接从你的SPA中调用函数或者通过AWS SDK调用本地应用。我自己没有尝试过，但是如果你注意到API网关是lazy的，这听起来似乎是一个提高性能的方法。



#### 无服务框架

我认为在构建一个无服务应用时框架是最复杂的一部分，比如一个项目的配置和部署。正如你所知道的的JAWS（Javascript Amazon Web Services），它是AWS的Javascript AWS Lambda apps的一个框架。它日渐变得复杂，今天它让我们无需选择任何语言。

#### 插件

无服务框架基于它自己提供的基本功能，但是如果你需要做一些高级的打包优化，本地运行代码，或者是建立具体的事件触发你的函数，那么你是幸运的因为有一个伟大的社区在用他们的插件为这个框架做贡献。大量创建无服务APP的插件模仿API网关功能是无服务离线的，让我们可以通过在无服务上声明的路由本地运行应用。yml就是不必手动地调用函数而可以提供HTTP具体的事件细节。

#### 项目结构

在单个入口下，serverless.yml文件是我们项目中最重要的文件，它支持基本项目的创建，比如选择一个供货商，声明安全组，资源，项目中用到的插件,环境配置以及项目中最后的函数清单，还有可以触发它们的具体的配置和事件。一个项目可以有全局配置，比如256MB的内存，Node.js 8.10的运行等等。它让我们可以准确地配置每个函数，这显然会覆盖全局的配置。

无服务也是事件驱动的体系结构，一个单函数可以监听几个不同类型的事件。我们习惯于创建APIs来监听HTTP请求（某些地方也可以通过应用或者使用网钩），但是使用无服务框架让我们可以监听并且触发事件函数比如内存，数据库，消息队列等等的变化。

这里有一个可以应用于项目基本的例子，可以在gihub仓库中找到。

![](https://jinuss.github.io/blog/jinus/img/20181101.png)

有一个名为handlers的文件夹,所有的函数按照功能分为几个文件夹，每个.js文件仅包含一个函数。我正在使用这种方法，它让我可以很容易地浏览项目。

文件夹middleware和utils包含了用于代码中的可重用代码（工具函数），middleware函数正在尝试模仿构建Express/Koa中用到的中间件模式。

在结构中我们可以看到两个用于环境的文件，.env.example.yml是一个包含需要存在于项目中的体系环境和用于通过process.env对象贯穿整个应用的变量。另外，.env.yml是环境实际的值，在我的例子中本地环境应该总是被git忽略，因此我们不会泄露环境细节/秘密。

#### 学习成果

##### 没有全局中间件

在web上用Express或者相似的框架时，在使用实际的路由级中间件之前，我们可以很容易的配置将被每个路由使用的中间件。这里并不存在这样的一个概念，因为每个函数（路由）可以充当一个完整的分离实体。因此，如果你想将中间件应用到每个函数，你不得不在每个函数文件中指定它。工作区将会创建一个包裹函数，它会被项目中的每个函数使用，并且负责必要的设置。这种中间件的例子像是错误中间件、主体解析中间件、设置响应头中间件等等。

#####  慎重地缩进serverless.yml文件

配置文件时一个.yml文件，意味着它依赖缩进来分组和构造传递的值。在为每个函数设置HTTP事件时,我总是碰到问题。它似乎是要求两个缩进而不是一个。

##### 状态需要存在，使用自定义域

当在AWS上部署一个无服务应用时，你项目中的API网关URL将会被构建，类似于 `https://my-api-id.execute-api.region-id.amazonaws.com/stage-name/{resourcePath}`  状态的名字默认为dev。我发现使用自定义作用域可以更方便工作，因为亚马逊提供的基础url显而易见太长了，并且在TLD后状态名会被混淆。

##### 总是将主体字符串化

有时候，我忘记将主体字符串化，本地一切运行正常（本地环境由无服务离线插件提供），但是当我部署app后，它就无法工作。这让我花了一段时间意识到我犯了一个愚蠢的错误，因为API网关期望一个字符串化的主体，而路由发送了一个原始对象，没有实际的解释，它将会抛出一个超时的错误。

##### 不要使用全局Promise

这里有一个我经历的有趣问题。使用pg-promise工作让你可以使用Promise库，所以你可以使用库提供的所有的Promsie功能，我们习惯于这样写`global.Promise=require('bluebird')`。在Express，Koa或者其他的任何框架中使用没有任何毛病，但是似乎比如Lambdas在它们的环境中有一个自己的Promise库，改变Promise库将会弄乱它。因此永远不要给API网关一个响应，这会导致函数运行长达15分钟，甚至超时，最后还是自己为错误买单。

##### 使用AWS Linux环境构建并打包项目

在Linux环境中你编写的代码会被AWS执行，这就意味着所有的代码和装载函数的模块得保证在这样一个环境中是可运行的。我使用苹果电脑工作，因此在我添加一个优化图片的模块之前，所有的模块在本地可以运行，在Lambda上也可以。这事你有两个方案：在相似的Linux环境中也配置CI并且构建diamante，把它部署到AWS，或者启动一个EC2 AWS Linuxs实例并在上面安装图片优化模块，本地下载，然后每次部署，都要确保从EC2中复制的实例都存在与你本地的node_modules文件夹中，重写OS-specifc模块。

#####  忘记 Sockets

如果你计划应用socket.io来处理无服务app的连接，忘记这个，找一个服务来处理这件事。永远运行的无服务函数没有被创建，这是实现套接字是最大的障碍。

##### 知道你的局限

如果你有利用大量函数构建无服务应用的想法，你需要意识到单个无服务应用（服务）可以在serverless.yml中声明60个函数，部署时如果超过了这个数目，你会得到一个错误。我就碰到这个问题，但是幸运的是我有一些没有用到的函数，因此我可以删除它们便于部署app。然而，如果你有一个项目，超过了60个函数，你将不得不拆分它们到不同的服务中去。我的观点是它都给应用程序增加了新的复杂性，无论是对于开发（必须运行几个不同的服务）还是通过自定义域配置多个网关部署到AWS上去。

##### 谷歌是你的朋友

当编写软件时，你会碰到各种问题。谷歌真的是你的朋友。无服务框架CLI当错误发生时会给你提供很多反馈，但是当你将应用部署到供货商时（我使用的AWS），你就开始犯错误。它们可能是由于AWS的一些局限，或者你的CloudFormation堆栈处于UPDATE_ROLLBACK_FAILED状态，你实际上必须使用AWS的接口才能再次部署你的堆栈。

无服务框架支持不同的商家，并且它们都会提供基本的功能，但是如果你的选择是AWS，当出现问题时你是幸运的，因为它有着最大的社区，有很多人和碰到一样的问题。在我不知道它们有什么社区时我不会尝试其他的供货商。

##### 结论

函数作为服务在云计算方面是很大的一步，尤其是我们正在寻找创造容易缩放的东西。

试想一下，如果你的产品在某些流行的网站上成为特色并且因为无法承载负荷而崩溃，会发生什么。Fass产品就很方便因为它伸缩性好，但是你也必须按照处理此类负载的方式编写产品。

我认为对于对于任务来说它是理想的，它不直接涉及用户，因此如果我们有冷启动对我们的用户体验没有影响。如果你决定使用面向前面的函数，确保分析使用情况并且保持某些函数warm来避免冷启动。如果你想在你的服务时上计算的更快，只是不能接受任何缓慢，Fass并不是你的选择。































