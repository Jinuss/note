---
categories:
 - Backbone
tags:
 - Backone
---
**Backbone**中，使用最多的莫过于在 _view_ 中进行操作，如模板的渲染以及事件函数的定义。为了提高代码的可维护性，一般地我们会写多个视图( _view_ )，将界面按照功能的不同进行模块化划分，模块与 _view_ 一一对应。

首先，我们会定义一个父 _view_ ，在view中控制不同子 _view_ 的渲染，子 _view_ 之间尽量不产生联系。这样，代码之间的耦合度会降低很多，模块的功能明确化，同时降低了开发的难度。最近在项目中遇到父子view传值问题，学习到了一个知识点，比较简单易懂。主要想分享两个内容：父子view是如何传值的和它们之间传值要注意什么。以我实际的项目为例进行说明。
  
 

*  如何传值    

 >  项目中利用**requireJs**按需加载js文件，大大地节约了资源。首先在 _global.js_ 中申明子 _view_ 的路径，方便在父 _view_ 中进行引用。**requireJs**是通过 _define_ 进行函数的定义以及相关依赖模块的引入，这里不必细说，假设参数定义为 _childrenView_ 。在父 _view_ 中new一个_childrenView_ 对象，这样我们通过自定义事件进行操作就行。此时new的对象包含_view_的_render_方法等。如果在_new childrenView_ (参数1)时，参数1可以为空，此时父子 _view_ 之间没有值传递；当参数2存在时，父子 _view_ 存在值传递，参数1是父 _view_ 传递给子 _view_ 的。在子 _view_ 的 _initialize_ (参数2)中可以接收参数1，即参数1和参数2是对等的。
 此外，因为是在父 _view_ 中new的子 _view_，可以在父 _view_ 可以对子 _view_ 进行操作。

* 细节问题

> 通过一我们可以很方便在子 _view_ 中接收父 _view_ 的数据，但是这里有个细节问题。我曾在这里困惑好久。参数最好不要传父 _view_，即父 _view_的this或者 _view_ 默认的事件函数等。因为这样做，参数会将子_view_默认的事件函数给覆盖，导致子 _view_ 相同的事件函数失效。简单来讲，如果父子 _view_ 都存在的，比如 _render_ ，_events_ 或者其他定义相同的值或者是自定义函数不能作为参数传递
