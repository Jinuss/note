---
categories:
- JavaScript
tags:
- 学习笔记
---

## 基本类型和引用类型

  ECMAScipt变量可能分为两种数据类型：基本类型和引用类型。

   1. 基本类型：指简单的数据段；包括Undefined、Null、Boolean、Number、String；可以操作保存在变量中值（栈内存），所以称为按值访问；不能添加属性。
   2. 引用类型：可能由多个值构成的对象；包括Arry、Object等；js不允许直接操作对象的内存（堆内存）空间，所以成为按引用访问；可以动态得添加/改变/删除引用类型值的属性和方法。

----

  - 复制


        var a=5;
        var b=a;
        console.log(a);//5
        console.log(b);//5
        a=3;
        console.log(a);//3
        console.log(b);//5
        var arrA=[1,2,3];
        var arrB=arrA;
        console.log(arrA);//[1,2,3]
        console.log(arrB);//[1,2,3]
        arrA[0]='x';
        console.log(arrA);//['x',2,3]
        console.log(arrB);//['x',2,3]

    上述代码中a、b为基本数据类型，arrA、arrB为引用类型。可以看出首先定义并初始化了变量a为5，再定义变量b，此时打印出来a和b都是5；改变a的值为3，再次打印，a为3，b为5。对于引用类型arrA以及arrB，进行类似的操作，会发现arrA和arrB的值保持一致。继续看如下代码

        var arrC=[1,2,3];
        var arrD=arrC;
        console.log(arrC);//[1,2,3]
        console.log(arrD);//[1,2,3]
        arrC=['X','Y','Z'];
        console.log(arrC);//['X','Y','Z']
       console.log(arrD);//[1,2,3]

    此时引用类型arrC、arrD的值并没有改变。这是因为基本类型是在变量对象上，而引用类型是保存在内存中。基本类型的变量是完全相互独立的，而引用类型变量的复制拷贝的实则上是一个指针，这个指针指向存储在内存中的对象。只要指针是指向改变的对象时，则通过这些指针访问的也会发生改变，如arrA、arrB。而arrC与arrD之所以前后没有保持一致，是因为arrC=['X','Y','Z']这个操作，是将arrC的指针指向了另一个对象，即['X','Y','Z']。而arrD的指针的指向并没有发生改变，仍然指向[1,2,3]。

   - 传递参数

     函数的参数传递是按值传递的，无论是基础类型还是引用类型。这一点书上说的很详细，可以参考书上P71页。

   - 检测类型

     typeof用来检测基本数据类型，instanceof用来检测引用类型。因为引用类型的值都是Object的实例，所以instanceof检测引用类型和object构造函数时返回true；反之instanceof检测基本类型时，由于基本类型不是对象，所以始终返回false。

## 执行环境及作用域

   Web浏览器中，全局执行环境被认为是window对象，所以所有全局变量和函数都是作为window对象的属性和方法创建的，不过一般省略了window。个人感觉这一小节内容还是比较容易理解的，执行环境就只分为两种：全局和局部。

   - 延长作用域链

     两种方法：try-catch和with语句。由于witch语句会给性能带来影响，所以以前者为例，catch语句会在作用域链的前端添加一个变量对象A，其中包含的是被抛出错误对象的申明，即在catch语句内部，可以引用对象A的属性或方法。

   - JS语言没有块级作用域

     由于访问局部变量不用向上搜索作用域链，所以访问局部变量要比访问全局变量要快。即使快的不明显，但是仍然要尽量避免使用全局变量，防止变量污染。

## 垃圾收集

   JS具有自动垃圾收集机制，所需内存的分配以及无用内存的回收完全实现了自动管理。其原理是：垃圾收集器会按照固定的时间间隔周期性地找出那些不再继续使用的变量，然后释放其占用的内存。局部变量在函数执行完毕时会自动被销毁。

  - JS垃圾收集方式有两种：标记清除和引用计数。

    前者最常用，简单来讲，垃圾收集器会给存储在内存中的所有变量加上标记，即进入执行环境的变量（占用内存）会被加上一个标记表示不会被清除；当变量要离开环境，执行完毕时，这些变量会再次被标记表示要被清除，此时环境中的变量已经访问不到这些变量。

    引用计数是指跟踪记录每个值被引用的次数。当声明一个变量并将一个引用类型赋值给该变量时，其引用次数为1，如果同一个值又被赋给另一个变量，则该值的引用次数家1；相反，如果包含对这个值引用的变量又取到另外一个值，则引用次数减1.当内存中值的引用次数为0时，其占用的内存空间会被回收。通俗来讲，引用次数就是指向内存对象的指针的个数。可以类比前面的arrC和arrD，如下图：


         var arrC=[1,2,3]; 
         var arrD=arrC;
         console.log(arrC);//[1,2,3]
         console.log(arrD);//[1,2,3]
         arrC=['X','Y','Z']; 
         console.log(arrC);//['X','Y','Z']
         console.log(arrD);//[1,2,3]

    首先内存中的值为[1,2,3],当声明arrC并将值[1,2,3]赋给arrC时，值的引用次数为1，即arrC的指针指向它。当将arrC的值赋给arrD时，值[1,2,3]的引用次数+1为2，此时arrC、arrD的指针都指向值[1,2,3]。接下来，将值['X','Y','Z']赋给arrC时，arrC的指针不再指向值[1,2,3],而是指向值['X','Y','Z'],此时arrD依旧指向值[1,2,3]。值[1,2,3]的引用次数减1为1。引用计数最大的弊端就是循环引用，即两个对象都包含指向对方的引用。

  - 性能问题

    垃圾收集器是周期运行的，时间间隔的确定会影响浏览器的性能。

  - 管理内存

    解除引用：将数据的值置为null，适用于大多数全局变量和全局对象的属性，其作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。
