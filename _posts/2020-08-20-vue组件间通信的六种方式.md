组件是vue最强大的功能之一，但组件实例的作用域是相互独立的，所以不同组件之间的数据无法相互引用。

针对不同的场景应该选择不同的方案实现组件之间的通信

#### `props`/(`$emit`和`v-on`)

- 父组件P通过``props`的方式向子组件C传递，C to P 通过在C组件中`$emit`,P组件中`v-on`的方式实现。

#### `$emit/$on`

- 通过一个空的vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件，实现任何组件间的通信。包括父子、兄弟、跨级。

#### `vuex`

[详见vuex介绍](vuex.html)

#### `$attrs`/`$listeners`

- `$attrs`:包含了父作用域中不被prop所识别（且获取）的特性绑定（class和style除外）。当一个组件没有声明任何prop时，这里会包含所有父作用域的绑定，并且可以通过`v-bind="$attrs"`传入内部组件。通常配合`interitAttrs`选项一起使用。
- `$listeners`:包含了父作用域中的（不含.native修饰器）的`v-on`事件监听器。它可以通过`v-on="$liteners"`传入内部组件。

#### `provide`/`inject`

这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，无论层次有多深，并在其上下游关系成立的时间里始终生效。一言以蔽之：祖先组件中通过`provide`来提供变量。然后在子孙组件中通过`inject`来注入变量。这主要解决了跨级组件间的通信问题，不过使用场景主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。

`provide`和`inject`并不是响应式的，如果传入了一个可监听的对象，那么其对象的属性还是可响应的。

可以通过`vue.observable`实现优化响应式

#### `#parent`/`$children`与`ref`

- `ref`:如果在普通的DOM元素上使用，引用指向的就是DOM元素；如果用在子组件上，引用就指向组件实例
- `$parent`/`$children`:访问父/子实例

这种无法实现跨级或兄弟组件进行通信