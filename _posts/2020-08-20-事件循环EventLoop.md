# JS浏览器事件循环EventLoop机制

### 进程、线程

 - 进程是系统分配的独立资源，是CPU资源分配的基本单位。进程是由一个或者多个线程组成
 - 线程是进程的执行流，是CPU调度和分派的基本单位，同个进程之中的多个线程之间是共享该进程的资源。

### 浏览器内核

 - 浏览器是多进程的，每一个tab标签代表一个独立的进程（但是多个空白的tab标签会合并成一个进程）
 - 浏览器内核（浏览器渲染进程）是浏览器多进程中的一种，主要分为：
   - GUI渲染线程：

     - 负责渲染页面，解析Html、CSS构成Render树等。当页面**重绘**或者**回流**都会调起该线程。
     - 和JS引擎线程是互斥的。当JS引擎线程在工作的时候，GUI渲染线程会被挂起，GUI更新被放入JS任务队列中，等待JS引擎线程空闲时继续执行。

   - JS引擎线程：

     - 单线程工作，负责解析运行JS脚本。  
     - 和GUI渲染线程互斥，JS运行耗时过长会导致页面阻塞。（script标签加 `def` 和 `async` <不保证执行顺序>）

   - 事件触发线程：

     - 当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到任务队列的队尾，等待JS引擎处理。

   - 定时器触发线程：

     - 浏览器定时计数器并不是由JS引擎技术的，阻塞会导致计时不准确。
     - 开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待JS引擎处理。

   - http请求线程：

     - http请求的时候会开启一条请求线程
     - 请求完成有了返回结果后，会将请求的回调函数添加到任务队列中，等待JS引擎处理。

### 事件循环机制

JS事件循环机制分为浏览器和Node事件循环机制，浏览器Event Loop是HTML中定义的规范，后者由libuv库实现。

JS有一个主线程（main thread）和调用栈（执行栈，即call-stack），所有的任务都会被放到调用栈中等待主线程执行。

  + JS调用栈：栈是一种后进先出的数据结构。当函数被调用时，会被添加到栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。 
  + 同步任务、异步任务：同步任务会在调用栈中按照顺序排队等待主线程执行，而异步任务则会在异步有了结果后将注册的回调函数添加到任务队列（先进先出的数据结构）中等待主线程空闲，即调用栈被清空时，被调取到栈中等待主线程执行。
  + 事件循环：当调用栈中的同步任务都执行完毕，就会按照顺序去读取任务队列中是否还有任务，有任务就将其读取到调用栈中等待执行，当调用栈再次清空时，会再次读取任务队列是否有任务，这个一直读取-调用执行-读取就形成了事件循环。

  
JS单线程中的任务除了广分为义的同步任务和异步任务，还可分为**宏任务**和**微任务**

> 宏任务(macro-task）：script(全局作用域中的同步代码)、 `setTimeout` 、 `setInterval` 、 `setImmediate` 、 `I/O` 、 `UI rendering`
> 微任务(micro-task)： `promise` 、 `process.netTick` 、 `Object.observe` 、 `MutainObserver`
微任务队列的优先级高于宏任务队列
